{
  "name": "Ratnet",
  "tagline": "Prototype anonymity network for mesh routing and embedded scenarios.",
  "body": "# What is Ratnet?\r\nRatnet is a library that allows applications to communicate using an *onion-routed* and *flood-routed* message bus.  All communications are encrypted end-to-end by the library itself.\r\n\r\nRatnet is completely modular, meaning that the interactions of all significant components of the system are defined with interfaces, and are therefore interchangeable.  Network transports, cryptosystems, connection policies, and the ratnet nodes themselves can all be customized and swapped around dynamically.\r\n\r\nThe Ratnet library provides two working implementations for each of these interfaces:\r\n\r\n- Network Transports:  [HTTPS](https://godoc.org/github.com/awgh/ratnet/transports/https) and [UDP](https://godoc.org/github.com/awgh/ratnet/transports/udp) are provided\r\n- Cryptosystems: [ECC](https://godoc.org/github.com/awgh/bencrypt/ecc) and [RSA](https://godoc.org/github.com/awgh/bencrypt/ecc) implementations are provided\r\n- Connection Policies: [Server](https://godoc.org/github.com/awgh/ratnet/policy#Server) and [Polling](https://godoc.org/github.com/awgh/ratnet/policy#Poll) are provided\r\n- Nodes: [QL Database Backed Node](https://godoc.org/github.com/awgh/ratnet/nodes/qldb) and a [RAM-only Node](https://godoc.org/github.com/awgh/ratnet/nodes/ram) are provided\r\n\r\nIt's also easy to implement your own replacement for any or all of these components.  Multiple transport modules can be used at once, and different cryptosystems can be used for the Onion-routing and for the content encryption, if desired.\r\n\r\nRatnet provides input and output channels for your application to send and receive binary messages in clear text, making it very easy to interact with.\r\n\r\n## What's a Connection Policy?\r\n\r\nYou caught me, I made that term up.  In ratnet, *Transports* are responsible for physically making and receiving connections and that's it.  *Nodes* are basically message queues with some key management and special knowledge about when to encrypt things (and the *Cryptosystem* is the method they would use to do that).  But none of those things actually starts a connection and moves the data around.  That is the responsibility of the *Connection Policy*.  Think of it as a script that controls a Node and any number of different Transports.  \r\n\r\nWe provide two very simple connection policies:\r\n\r\n1. Server - This just opens up a port and listens on it.\r\n2. Polling - After a delay, this will connect to every Peer and exchange messages.\r\n\r\nIn real-world usage, you're very likely to want to implement your own version of Polling (via the [Policy](https://github.com/awgh/ratnet/blob/master/api/policy.go) interface), so you can tune retry logic and so on.  We will be doing a lot more development and experimentation with new policies in the future.\r\n\r\n\r\n# Examples\r\n\r\n## Fully Working Demo App\r\n\r\n[Hushcom](https://github.com/awgh/hushcom) is a fully working demo app that implements IRC-like chat functionality with a client and a server.\r\n\r\nThe [hushcom client application](https://github.com/awgh/hushcom/blob/master/hushcom/main.go) is a good reference for how to set up a client using the Poll connection policy.\r\n\r\nThe [hushcomd server application](https://github.com/awgh/hushcom/blob/master/hushcom/main.go) is a good reference for how to set up a server using the Server connection policy.\r\n\r\n## Making a Node\r\n\r\nMake a QL-Database-Backed Node, which saves states to disk:\r\n```go\r\n\t// QLDB Node Mode\r\n\tnode := qldb.New(new(ecc.KeyPair), new(ecc.KeyPair))\r\n\tnode.BootstrapDB(dbFile)\r\n```\r\n\r\nOr, make a RAM-Only Node, which won't write anything to the disk:\r\n```go\r\n\t// RamNode Mode:\r\n\tnode := ram.New(new(ecc.KeyPair), new(ecc.KeyPair))\r\n```\r\n\r\nThe KeyPairs passed in as arguments are just used to determine which cryptosystem should be used for the Onion-Routing (first argument) and for the Content Encryption (second argument).  \r\n\r\n## Setup Transports and Policies \r\n\r\n```go\r\n\ttransportPublic := https.New(\"cert.pem\", \"key.pem\", node, true)\r\n\ttransportAdmin := https.New(\"cert.pem\", \"key.pem\", node, true)\r\n\tnode.SetPolicy(\r\n\t\tpolicy.NewServer(transportPublic, listenPublic, false),\r\n\t\tpolicy.NewServer(transportAdmin, listenAdmin, true))\r\n\r\n\tlog.Println(\"Public Server starting: \", listenPublic)\r\n\tlog.Println(\"Control Server starting: \", listenAdmin)\r\n\r\n\tnode.Start()\r\n```\t\r\n\r\n## Handle messages coming from the network\r\n\r\n```go\t\r\n\tgo func() {\r\n\t\tfor {\r\n\t\t\tmsg := <-node.Out()\r\n\t\t\tif err := HandleMsg(msg); err != nil {\r\n\t\t\t\tlog.Println(err.Error())\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n```\r\n\r\n## Send messages to the network\r\n\r\nBlocking Send:\r\n```go\r\n\tmessage := api.Msg{Name: \"destname1\", IsChan: false}\r\n\tmessage.Content = bytes.NewBufferString(testMessage1)\r\n\tnode.In() <- message\r\n```\r\n\t\r\nNon-Blocking Send:\r\n```go\r\n        select {\r\n\t\tcase node.Out() <- message:\r\n\t\t\t//fmt.Println(\"sent message\", msg)\r\n\t\tdefault:\r\n\t\t\t//fmt.Println(\"no message sent\")\r\n\t\t}\t\r\n```\r\n\r\n# Additional Documentation\r\n\r\n- Overview Slide Deck from Toorcamp 2016 [here](https://github.com/awgh/ratnet/blob/master/docs/RatNet-Toorcamp16-v1.pdf).\r\n- API Docs are available [here](https://godoc.org/github.com/awgh/ratnet/api).\r\n\r\n# Related Projects\r\n\r\n- [Bencrypt, crypto abstraction layer & utils](https://github.com/awgh/bencrypt)\r\n- [Ratnet, onion-routed messaging system with pluggable transports](https://github.com/awgh/ratnet)\r\n- [HushCom, simple IRC-like client & server](https://github.com/awgh/hushcom)\r\n\r\n#Authors and Contributors\r\n\r\n- awgh@awgh.org (@awgh)\r\n\r\n- vyrus001@gmail.com (@vyrus001)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}